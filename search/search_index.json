{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introducci\u00f3n Esto es una gu\u00eda para aquellos que parten en el mundo de la programaci\u00f3n competitiva. Se planea cubrir los paradigmas b\u00e1sicos que se ense\u00f1an en los cursos de Taller de Programaci\u00f3n Avanzada/Competitiva IIC255 y IIC2553 de la Pontifica Universidad Cat\u00f3lica de Chile. Espero les sea de utilidad y se maravillen. \u2014 Warp.","title":"Home"},{"location":"#introduccion","text":"Esto es una gu\u00eda para aquellos que parten en el mundo de la programaci\u00f3n competitiva. Se planea cubrir los paradigmas b\u00e1sicos que se ense\u00f1an en los cursos de Taller de Programaci\u00f3n Avanzada/Competitiva IIC255 y IIC2553 de la Pontifica Universidad Cat\u00f3lica de Chile. Espero les sea de utilidad y se maravillen. \u2014 Warp.","title":"Introducci\u00f3n"},{"location":"setup/cpp/","text":"C++ en Programaci\u00f3n Competitiva C++ es el lenguaje m\u00e1s usado en la programaci\u00f3n competitiva. Esto se debe a su rapidez en tiempo de ejecuci\u00f3n, que es junto con el l\u00edmite de memoria, una de las restrcciones que se solicitan en los problemas de programaci\u00f3n. Instalaci\u00f3n C++ es un lenguaje compilado, es decir, un lenguaje que requiere de primero de ser pasado a un archivo de c\u00f3digo m\u00e1quina o ejecutable. Windows Pueden instalar g++ utilizando MYSYS2 con la siguiente gu\u00eda . Linux/Mac Normalmente los sistemas unix ya traen consigo el compilador g++. Para revisar si lo tienes instalado puedes ocupar g++ --version y si ya lo tienes instalado te aparecer\u00e1 algo como g++ ( GCC ) 12 .1.0 En caso que no te aparezca esto, puedes colacar instalarlo colocando en tu terminal; Mac brew install gcc Ubuntu/Debian sudo apt install g++ ArchLinux sudo pacman -S g++ Uso Creamos el archivo hola_mundo.cpp #include <iostream> using namespace std ; int main () { cout << \"\u00a1Hola mundo!\" << endl ; return 0 ; } luego abriendo la terminal en el directorio donde se guard\u00f3 este archivo, tienes que correr el comando g++ hola_mundo.cpp -o hola_mundo.out esto crear\u00e1 un archivo ejecutable llamado hola_mundo.out . Entonces podemos utilizar ./hola_mundo.out para ejecutar el programa ya comilado. \u00a1Hola mundo!","title":"C++"},{"location":"setup/cpp/#c-en-programacion-competitiva","text":"C++ es el lenguaje m\u00e1s usado en la programaci\u00f3n competitiva. Esto se debe a su rapidez en tiempo de ejecuci\u00f3n, que es junto con el l\u00edmite de memoria, una de las restrcciones que se solicitan en los problemas de programaci\u00f3n.","title":"C++ en Programaci\u00f3n Competitiva"},{"location":"setup/cpp/#instalacion","text":"C++ es un lenguaje compilado, es decir, un lenguaje que requiere de primero de ser pasado a un archivo de c\u00f3digo m\u00e1quina o ejecutable.","title":"Instalaci\u00f3n"},{"location":"setup/cpp/#windows","text":"Pueden instalar g++ utilizando MYSYS2 con la siguiente gu\u00eda .","title":"Windows"},{"location":"setup/cpp/#linuxmac","text":"Normalmente los sistemas unix ya traen consigo el compilador g++. Para revisar si lo tienes instalado puedes ocupar g++ --version y si ya lo tienes instalado te aparecer\u00e1 algo como g++ ( GCC ) 12 .1.0 En caso que no te aparezca esto, puedes colacar instalarlo colocando en tu terminal; Mac brew install gcc Ubuntu/Debian sudo apt install g++ ArchLinux sudo pacman -S g++","title":"Linux/Mac"},{"location":"setup/cpp/#uso","text":"Creamos el archivo hola_mundo.cpp #include <iostream> using namespace std ; int main () { cout << \"\u00a1Hola mundo!\" << endl ; return 0 ; } luego abriendo la terminal en el directorio donde se guard\u00f3 este archivo, tienes que correr el comando g++ hola_mundo.cpp -o hola_mundo.out esto crear\u00e1 un archivo ejecutable llamado hola_mundo.out . Entonces podemos utilizar ./hola_mundo.out para ejecutar el programa ya comilado. \u00a1Hola mundo!","title":"Uso"},{"location":"setup/template/","text":"Template de C++ La template que yo ocupo es: #pragma GCC optimize(\"Ofast\") #include <bits/stdc++.h> using namespace std ; #define rep(i, n) for (int i = 0; i < n; ++i) #define rep_(i, k, n) for (int i = k; i < n; ++i) using ll = long long ; int main () { ios_base :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . setf ( ios :: fixed ); cout . precision ( 10 ); // Soluci\u00f3n aqu\u00ed return 0 ; } Explicaci\u00f3n #pragma GCC optimize(\"Ofast\") : hace optimizaciones internas al momento de compilar. #include <bits/stdc++.h> : nos importa la basta mayor\u00eda de herramientas (estructuras de datos y funciones varias) que se ocupan en programaci\u00f3n competitiva. using namespace std : indicamos que vamos a utilizar la librer\u00eda est\u00e1ndar. #define rep... : nos crea alias para las funciones que queramos. En este caso hacemos alias para los for . using ll = long long : alias para el tipo de dato long long . ios_base::sync_with_stdio(false)... : optimizamos el uso de cin y cout . Esto hace que se imprima en pantalla cuando ya se hallan entregado todo los inputs al programa. Se debe quitar en problemas interactivos. cout.precision(10) : indicamos que los n\u00fameros despu\u00e9s de la coma a imprimir son 10.","title":"Template"},{"location":"setup/template/#template-de-c","text":"La template que yo ocupo es: #pragma GCC optimize(\"Ofast\") #include <bits/stdc++.h> using namespace std ; #define rep(i, n) for (int i = 0; i < n; ++i) #define rep_(i, k, n) for (int i = k; i < n; ++i) using ll = long long ; int main () { ios_base :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . setf ( ios :: fixed ); cout . precision ( 10 ); // Soluci\u00f3n aqu\u00ed return 0 ; }","title":"Template de C++"},{"location":"setup/template/#explicacion","text":"#pragma GCC optimize(\"Ofast\") : hace optimizaciones internas al momento de compilar. #include <bits/stdc++.h> : nos importa la basta mayor\u00eda de herramientas (estructuras de datos y funciones varias) que se ocupan en programaci\u00f3n competitiva. using namespace std : indicamos que vamos a utilizar la librer\u00eda est\u00e1ndar. #define rep... : nos crea alias para las funciones que queramos. En este caso hacemos alias para los for . using ll = long long : alias para el tipo de dato long long . ios_base::sync_with_stdio(false)... : optimizamos el uso de cin y cout . Esto hace que se imprima en pantalla cuando ya se hallan entregado todo los inputs al programa. Se debe quitar en problemas interactivos. cout.precision(10) : indicamos que los n\u00fameros despu\u00e9s de la coma a imprimir son 10.","title":"Explicaci\u00f3n"},{"location":"tecnicas/recursion/","text":"Recursi\u00f3n La recursi\u00f3n es una t\u00e9cnica de programaci\u00f3n que se utiliza para resolver problemas de forma muy elegante. La idea es pensar en una funci\u00f3n que se llama a s\u00ed misma. La recurs\u00f3n debe poseer un caso base, el cual va a ser la \u00faltima vez que se llame a la funci\u00f3n, para luego devolverse a la primera llamada y ahi retornar. Caso contrario que no existiese dicho caso base, nuestra funci\u00f3n no terminar\u00eda. De buenas a primeras no es tan f\u00e1cil ver la recursi\u00f3n en un problema, por lo cual es \u00fatil revisar unos t\u00edpicos ejemplos.","title":"Recursi\u00f3n"},{"location":"tecnicas/recursion/#recursion","text":"La recursi\u00f3n es una t\u00e9cnica de programaci\u00f3n que se utiliza para resolver problemas de forma muy elegante. La idea es pensar en una funci\u00f3n que se llama a s\u00ed misma. La recurs\u00f3n debe poseer un caso base, el cual va a ser la \u00faltima vez que se llame a la funci\u00f3n, para luego devolverse a la primera llamada y ahi retornar. Caso contrario que no existiese dicho caso base, nuestra funci\u00f3n no terminar\u00eda. De buenas a primeras no es tan f\u00e1cil ver la recursi\u00f3n en un problema, por lo cual es \u00fatil revisar unos t\u00edpicos ejemplos.","title":"Recursi\u00f3n"},{"location":"tecnicas/recursion/fibonacci/","text":"Secuencia de fibonacci Es una secuencia muy conocida en el mundo matematico, la cual se define de forma recursiva como: \\(f_0 = 0\\) \\(f_1 = 1\\) \\(f_n = f_{n-1} + f_{n-2} \\quad \\forall n \\geq 2\\) Podemos echar cuentas y ver que la secuencia va de la siguiente forma: \\(0, 1, 1, 2, 3, 5, 8, 13, 21, \\ldots\\) En c\u00f3digo Intentemos hacer un programa que nos calcule la secuencia de fibonacci para un n\u00famero dado ( \\(n\\) ). Para ello, vamos a definir una funci\u00f3n recursiva que nos calcule el \\(n\\) -\u00e9simo t\u00e9rmino de la secuencia. def fibonacci ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fibonacci ( n - 1 ) + fibonacci ( n - 2 ) print ( fibonacci ( 10 )) Como es claro, los casos base son los dos primeros valores de la secuencia. Mientras que el resto se calcula llamando computando los dos valores de fibonacci anteriores. En C++ la funcion seria la siguiente: int fibonacci ( int n ) { if ( n == 0 ) { return 0 ; } else if ( n == 1 ) { return 1 ; } else { return fibonacci ( n -1 ) + fibonacci ( n -2 ); } } Desventaja El problema con esta implementaci\u00f3n es que se est\u00e1n calculando valores de la suceci\u00f3n varias veces. Se aprecia que se calcula fibonacci(3) dos veces que no est\u00e1 mal. Pero notemos que fibonacci(2) se llega a calcular tres veces. Para n\u00fameros m\u00e1s grandes este problema se vuelve aun peor. De hecho la complejidad de esta funci\u00f3n es de \\(\\mathcal{O}(\\phi^n)\\) , donde \\(\\phi = \\frac{1+\\sqrt{5}}{2}\\) . Ya que la cantidad de llamadas para fibonacci(n) es precisamente el n\u00famero de fibonacci \\(n\\) -esimo, que por una f\u00f3rmula conocida es \\[ f_n = \\frac{ (\\phi)^n - (\\Phi)^n }{\\sqrt{5}} \\] donde \\(\\Phi = \\frac{1-\\sqrt{5}}{2}\\) . M\u00e1s adelante veremos una optimizaci\u00f3n a esta problema. Pero adelantamos que dicha optimizaci\u00f3n hace que el algoritmo tenga complejidad lineal.","title":"Secuencia de fibonacci"},{"location":"tecnicas/recursion/fibonacci/#secuencia-de-fibonacci","text":"Es una secuencia muy conocida en el mundo matematico, la cual se define de forma recursiva como: \\(f_0 = 0\\) \\(f_1 = 1\\) \\(f_n = f_{n-1} + f_{n-2} \\quad \\forall n \\geq 2\\) Podemos echar cuentas y ver que la secuencia va de la siguiente forma: \\(0, 1, 1, 2, 3, 5, 8, 13, 21, \\ldots\\)","title":"Secuencia de fibonacci"},{"location":"tecnicas/recursion/fibonacci/#en-codigo","text":"Intentemos hacer un programa que nos calcule la secuencia de fibonacci para un n\u00famero dado ( \\(n\\) ). Para ello, vamos a definir una funci\u00f3n recursiva que nos calcule el \\(n\\) -\u00e9simo t\u00e9rmino de la secuencia. def fibonacci ( n ): if n == 0 : return 0 elif n == 1 : return 1 else : return fibonacci ( n - 1 ) + fibonacci ( n - 2 ) print ( fibonacci ( 10 )) Como es claro, los casos base son los dos primeros valores de la secuencia. Mientras que el resto se calcula llamando computando los dos valores de fibonacci anteriores. En C++ la funcion seria la siguiente: int fibonacci ( int n ) { if ( n == 0 ) { return 0 ; } else if ( n == 1 ) { return 1 ; } else { return fibonacci ( n -1 ) + fibonacci ( n -2 ); } }","title":"En c\u00f3digo"},{"location":"tecnicas/recursion/fibonacci/#desventaja","text":"El problema con esta implementaci\u00f3n es que se est\u00e1n calculando valores de la suceci\u00f3n varias veces. Se aprecia que se calcula fibonacci(3) dos veces que no est\u00e1 mal. Pero notemos que fibonacci(2) se llega a calcular tres veces. Para n\u00fameros m\u00e1s grandes este problema se vuelve aun peor. De hecho la complejidad de esta funci\u00f3n es de \\(\\mathcal{O}(\\phi^n)\\) , donde \\(\\phi = \\frac{1+\\sqrt{5}}{2}\\) . Ya que la cantidad de llamadas para fibonacci(n) es precisamente el n\u00famero de fibonacci \\(n\\) -esimo, que por una f\u00f3rmula conocida es \\[ f_n = \\frac{ (\\phi)^n - (\\Phi)^n }{\\sqrt{5}} \\] donde \\(\\Phi = \\frac{1-\\sqrt{5}}{2}\\) . M\u00e1s adelante veremos una optimizaci\u00f3n a esta problema. Pero adelantamos que dicha optimizaci\u00f3n hace que el algoritmo tenga complejidad lineal.","title":"Desventaja"},{"location":"tecnicas/recursion/generar_subconjuntos/","text":"Generar subconjuntos Veamos c\u00f3mo generar todos los subconjuntos de un conjunto dado. Supongamos por simplicidad que tenemos el conjunto cuyos elementos son los numeros del 1 al 3: \\(\\{1, 2, 3\\}\\) . Luego sus subconjuntos son \\(\\emptyset, \\{1\\}, \\{2\\}, \\{3\\}, \\{1, 2\\}, \\{1, 3\\}, \\{2, 3\\}, \\{1, 2, 3\\}\\) . Para ver la recursi\u00f3n hay que pensar en un argumento que nos proporcione una informaci\u00f3n \u00fatil. En este caso, los argumentos ser\u00e1n; el elemento \\(i\\) no forma parte del subconjunto y el subconjunto que estamos generando. El caso base es cuando llegamos a revisar si a\u00f1adir el \\(0\\) que como no est\u00e1 en el conjunto original podemos imprimir el subconjunto formado. Asi en cada llamada lo que hace la recursion es bifurar en dos mundos paralelos: uno en donde se a\u00f1ade el elemento que estamos viendo al subconjunto y otro en el que no. C\u00f3digo El c\u00f3digo en python utilizando listas puede ser: def all_subset ( n , subset ): if n == 0 : print ( subset ) else : all_subset ( n - 1 , subset ) all_subset ( n - 1 , subset + [ n ]) all_subset ( 3 , []) El c\u00f3digo en C++ utilizando vector puede ser: void all_subset ( int n , vector < int >& subset ) { if ( n == 0 ) { print_subset ( subset ); } else { all_subset ( n -1 , subset ); subset . push_back ( n ); all_subset ( n -1 , subset ); } } Notese que se esta ocupando vector<int>& subset comoa argumento. Esto hace que no se tenga que copiar el vector en cada llamada, sino que se pasa por referencia y se modifica el mismo vector.","title":"Generar subconjuntos"},{"location":"tecnicas/recursion/generar_subconjuntos/#generar-subconjuntos","text":"Veamos c\u00f3mo generar todos los subconjuntos de un conjunto dado. Supongamos por simplicidad que tenemos el conjunto cuyos elementos son los numeros del 1 al 3: \\(\\{1, 2, 3\\}\\) . Luego sus subconjuntos son \\(\\emptyset, \\{1\\}, \\{2\\}, \\{3\\}, \\{1, 2\\}, \\{1, 3\\}, \\{2, 3\\}, \\{1, 2, 3\\}\\) . Para ver la recursi\u00f3n hay que pensar en un argumento que nos proporcione una informaci\u00f3n \u00fatil. En este caso, los argumentos ser\u00e1n; el elemento \\(i\\) no forma parte del subconjunto y el subconjunto que estamos generando. El caso base es cuando llegamos a revisar si a\u00f1adir el \\(0\\) que como no est\u00e1 en el conjunto original podemos imprimir el subconjunto formado. Asi en cada llamada lo que hace la recursion es bifurar en dos mundos paralelos: uno en donde se a\u00f1ade el elemento que estamos viendo al subconjunto y otro en el que no.","title":"Generar subconjuntos"},{"location":"tecnicas/recursion/generar_subconjuntos/#codigo","text":"El c\u00f3digo en python utilizando listas puede ser: def all_subset ( n , subset ): if n == 0 : print ( subset ) else : all_subset ( n - 1 , subset ) all_subset ( n - 1 , subset + [ n ]) all_subset ( 3 , []) El c\u00f3digo en C++ utilizando vector puede ser: void all_subset ( int n , vector < int >& subset ) { if ( n == 0 ) { print_subset ( subset ); } else { all_subset ( n -1 , subset ); subset . push_back ( n ); all_subset ( n -1 , subset ); } } Notese que se esta ocupando vector<int>& subset comoa argumento. Esto hace que no se tenga que copiar el vector en cada llamada, sino que se pasa por referencia y se modifica el mismo vector.","title":"C\u00f3digo"}]}